#include "init.h"
#include "MDR32F9x.h"

// Инициализация тактового генератора
//MDR_RST_CLK - Контроллер тактовой частоты, базов адр 0x4002_0000
void Clock_Init (void)
{	
	MDR_RST_CLK->HS_CONTROL = RST_CLK_HS_CONTROL_HSE_ON;															// 0x00000001 - Тактирование от внешнего кварца
	while ((MDR_RST_CLK->CLOCK_STATUS & RST_CLK_CLOCK_STATUS_HSE_RDY)==0)			{	}			// 0x00000004 - Ожидание стабилиазации кварца

//	MDR_RST_CLK->PLL_CONTROL = (9<<RST_CLK_PLL_CONTROL_PLL_CPU_MUL_Pos) | 						// Коэффициент умножения для ядра равен x+1=10, т.е. 10*8=80МГц
//															RST_CLK_PLL_CONTROL_PLL_CPU_ON;												// 0<<8|4. Бит включения PLL

//	MDR_RST_CLK->PLL_CONTROL = (4<<RST_CLK_PLL_CONTROL_PLL_CPU_MUL_Pos) | 						// Коэффициент умножения для ядра равен x+1=5, т.е. 5*8=40МГц
//															RST_CLK_PLL_CONTROL_PLL_CPU_ON;												// 0<<8|4. Бит включения PLL

	MDR_RST_CLK->PLL_CONTROL = (2<<RST_CLK_PLL_CONTROL_PLL_CPU_MUL_Pos) | 						// Коэффициент умножения для ядра равен x+1=10, т.е. 3*8=24МГц
															RST_CLK_PLL_CONTROL_PLL_CPU_ON;												// 0<<8|4. Бит включения PLL

	while ((MDR_RST_CLK->CLOCK_STATUS & RST_CLK_CLOCK_STATUS_PLL_CPU_RDY)==0)	{	}			// Ожидание стабилиазации умножителя

	MDR_RST_CLK->CPU_CLOCK = ((RST_CLK_CPU_CLOCK_CPU_C1_SEL_Msk & 0x02) | 						// 0x3&0x2=HSE Выбор внешнего кварца в качестве общего источника тактирования,
														 RST_CLK_CPU_CLOCK_CPU_C2_SEL |													// 0x4
														(RST_CLK_CPU_CLOCK_CPU_C3_SEL_Msk & 0x0) |							// использование умноженной частоты кварца
														(1<<RST_CLK_CPU_CLOCK_HCLK_SEL_Pos));										// 1<<8 Биты выбора источника для HCLK: 01 – CPU_C3

// Подача тактирования на:		UART2, 	ADC, порты A, 		B, 			C, 			D, 			E,			F
//	MDR_RST_CLK->PER_CLOCK |= (1<<7)|(1<<17)|(1<<21)|(1<<22)|(1<<23)|(1<<24)|(1<<25)|(1<<29);	
//	 						 							Timer1,  ADC, порты A, 		B, 			C,			D, 			E				F.
	MDR_RST_CLK->PER_CLOCK |=  (1<<14)|(1<<17)|(1<<21)|(1<<22)|(1<<23)|(1<<24)|(1<<25)|(1<<29);	
//	 						 						 ADC, порты A, 		B, 			D, 			E.
//	MDR_RST_CLK->PER_CLOCK |= (1<<17)|(1<<21)|(1<<22)|(1<<24)|(1<<25);	

}

//---------------------------------------------------------------------------------------------------------------------------------
// Инициализация системного таймера
void SysTickInit(uint32_t nMks)															// Значение в микросекундах
{
//	SysTick->LOAD = nMks*80;																	// HCLK = 80MHz
//	SysTick->LOAD = nMks*40;																	// HCLK = 40MHz
	SysTick->LOAD = nMks*24;																	// HCLK = 24MHz
	SysTick->CTRL = 1<<2|1<<1|1;															// Источник синхросигнала HCLK, разрешение прерывания, работа таймера разрешена
}

//---------------------------------------------------------------------------------------------------------------------------------
// Инициализация оконного сторожевого таймера в классическом режиме
// При частоте ядра 8 МГц период срабатывания составляет около 4 мс
void WWDT_Init (void)
{//част таймера (PCLK/4096)/8	110000000			1111111
	MDR_WWDG->CFR |= (WWDG_CFR_WGTB_Msk | WWDG_CFR_W_Msk);			// Максимальный делитель частоты, максимальный размер окна, прерывания выключены
}

//---------------------------------------------------------------------------------------------------------------------------------
// Инициализация всех портов 
void Ports_Init (void)
{
	// Инициализация порта A								 PA4,PA3,PA2,PA1,PA0
//	MDR_PORTA->OE = 0x0000001F ;							// PA6,PA4-PA0 выход
//	MDR_PORTA->FUNC = 0x00000000;							// Функция порта для всех выводов
//	MDR_PORTA->ANALOG = 0x0000001f;						// Цифровой режим для всех задейсвованных выводов
//	MDR_PORTA->PWR = 0x000002aa;							// Быстрый фронт

	MDR_PORTA->OE = 0x0000001F | (1 << 6);		// PA6,PA4-PA0 выход
	MDR_PORTA->FUNC = 0x00000000;							// Функция порта для всех выводов
	MDR_PORTA->ANALOG = 0x0000001f |(1 << 6);	// Цифровой режим для всех задейсвованных выводов
	MDR_PORTA->PWR = 0x000002aa |(2 << 6);		// Быстрый фронт

//	MDR_PORTA->OE 		= 0x000000ff;							// Все выходы
//	MDR_PORTA->FUNC 	= 0x00000000;							// Функция порта для всех выводов
//	MDR_PORTA->ANALOG = 0x000000ff;							// Цифровой режим для всех задейсвованных выводов
//	MDR_PORTA->PWR 		= 0x000056aa;							// Быстрый фронт

	MDR_PORTA->RXTX &= ~0x10;									// Отключить РС															// PA3=1, PA4=0

	// Инициализация порта B								 PB5..10 - IQ15..20
 	MDR_PORTB->OE = 0x000007e0;						// Выводы настроены на выход
 	MDR_PORTB->FUNC = 0x00000000;					// Функция порта
 	MDR_PORTB->ANALOG = 0x000007e0;				// Цифровой режим для всех выводов
 	MDR_PORTB->PWR = 0x002aa800;					// Быстрый фронт
 	//MDR_PORTB->PWR = 0x003ffc00;					// Cамый быстрый фронт
	
	// Инициализация порта C								 PC1, PC0 - IQ3..1
 	MDR_PORTC->OE = 0x00000003;						// Выводы настроены на выход
 	MDR_PORTC->FUNC = 0x00000000;					// Функция порта
 	MDR_PORTC->ANALOG = 0x00000003;				// Цифровой режим
 	MDR_PORTC->PWR = 0x0000000a;					// Быстрый фронт			//Cамый быстрый фронт
	
	// Инициализация порта D								 PD7, PD6, PD5, PD4, PD3, PD2, PD1, PD0
	MDR_PORTD->OE = 0x00000000;						// Все выводы настроены на вход
	MDR_PORTD->FUNC = 0x00000000;					// Функция порта, хотя для аналогового режима и не важно
	MDR_PORTD->ANALOG = 0x00000000;				// Аналоговый режим
	MDR_PORTD->PWR = 0x00000000;					// Отключаем передатчик порта
	
	// Инициализация порта E								 		PE7, PE6, 				PE3, PE2,	 PE1, PE0
 	MDR_PORTE->OE = 0x0000008e;						// Вывод 7,6 - CAN2; 3,2 - порт; 1,0 - CAN1, 
// 	MDR_PORTE->FUNC = 0x0000a00a;					// 			1010		0000		0000			1111
 	MDR_PORTE->FUNC = 0x0000a00f;					// 			1010		0000		0101			1111
 	MDR_PORTE->ANALOG = 0x000000cf;				// Цифровой режим для выводов 7, 6, 3, 2, 1, 0.
 	MDR_PORTE->PWR = 0x0000a0aa;					// Быстрые фронты		1010		0000		1010		1010

//	MDR_PORTE->RXTX &= ~0xC;							// Сброс сигналов Запрет заряда, Запрет разряда 

	// Инициализация порта F							 	 PF3, PF2, PF1, PF0
// 	MDR_PORTF->OE = 0x0000000E;						// Вывод 3 - выход
// 	MDR_PORTF->FUNC = 0x0000000F;					// Выдоды 0,1,2 - UART2
// 	MDR_PORTF->ANALOG = 0x0000000F;				// Цифровой режим для выводов 0,1,2,4
// 	MDR_PORTF->PWR = 0x000000FF;					// Самые быстрые фронты для UART, у остальных мдленные

		//CAN2	только для отладочной платы....................................................................................
//	MDR_PORTF->OE			|= (0<<2) | (1<<3);                     
//	MDR_PORTF->FUNC   |= (3<<4) | (3<<6); 											//3 - переопред 2 - альтернат 1 - основ 0 - порт
//	MDR_PORTF->ANALOG |= (1<<2) | (1<<3);                 
//	MDR_PORTF->PWR		|= (2<<4) | (2<<6);													//2 - быстрый порт

}

//---------------------------------------------------------------------------------------------------------------------------------
// Инициализация всех портов 
void Ports_Init_Tst (void)
{
//...................................................................................
//	 						 								Timer1,  ADC, порты A, 		B, 			D, 			E			F.
//	MDR_RST_CLK->PER_CLOCK |=  (1<<14)|(1<<17)|(1<<21)|(1<<22)|(1<<24)|(1<<25)|(1<<29);	
	MDR_RST_CLK->PER_CLOCK |=  (1<<17)|(1<<21)|(1<<22)|(1<<24)|(1<<25)|(1<<29);	
	
//...................................................................................
	// Инициализация порта A								 PA4,PA3,PA2,PA1,PA0
	MDR_PORTA->OE = 0x0000001F;						// 4-0 выход IQ11..IQ7
	MDR_PORTA->FUNC = 0x00000000;					// Функция порта для всех выводов
	MDR_PORTA->ANALOG = 0x0000001f;				// Цифровой режим для всех задейсвованных выводов
	MDR_PORTA->PWR = 0x000002aa;					// Быстрый фронт
	
	// Инициализация порта B								 PB5..10 - IQ15..20
// 	MDR_PORTB->OE = 0x000007e0;						// Выводы настроены на выход
// 	MDR_PORTB->FUNC = 0x00000000;					// Функция порта
// 	MDR_PORTB->ANALOG = 0x000007e0;				// Цифровой режим для всех выводов
// 	MDR_PORTB->PWR = 0x002aa800;					// Быстрый фронт
// 	MDR_PORTB->PWR = 0x003ffc00;					// Cамый быстрый фронт
	
	// Инициализация порта C								 PC2, PC1, PC0 - IQ3..1
// 	MDR_PORTC->OE = 0x00000007;						// Выводы настроены на выход
// 	MDR_PORTC->FUNC = 0x00000000;					// Функция порта
// 	MDR_PORTC->ANALOG = 0x00000007;				// Цифровой режим
// 	MDR_PORTC->PWR = 0x0000003f;					// Cамый быстрый фронт
	
	// Инициализация порта D								 PD7, PD6, PD5, PD4, PD3, PD2, PD1, PD0
	MDR_PORTD->OE = 0x00000000;						// Все выводы настроены на вход
	MDR_PORTD->FUNC = 0x00000000;					// Функция порта, хотя для аналогового режима и не важно
	MDR_PORTD->ANALOG = 0x00000000;				// Аналоговый режим
	MDR_PORTD->PWR = 0x00000000;					// Отключаем передатчик порта
	
	// Инициализация порта E								 		PE7, PE6, 				PE3, PE2,	 PE1, PE0
// 	MDR_PORTE->OE = 0x0000008e;						// Вывод 7,6 - CAN2; 3,2 - порт; 1,0 - CAN1, 
// 	MDR_PORTE->FUNC = 0x0000a00f;					// 			1010		0000		0000			1111
// 	MDR_PORTE->ANALOG = 0x000000cf;				// Цифровой режим для выводов 7, 6, 3, 2, 1, 0.
// 	MDR_PORTE->PWR = 0x0000a0aa;					// Быстрые фронты		1010		0000		1010		1010

	// Инициализация порта F							 	 PF3, PF2, PF1, PF0
// 	MDR_PORTF->OE = 0x0000000E;						// Вывод 3 - выход
// 	MDR_PORTF->FUNC = 0x0000000F;					// Выдоды 0,1,2 - UART2
// 	MDR_PORTF->ANALOG = 0x0000000F;				// Цифровой режим для выводов 0,1,2,4
// 	MDR_PORTF->PWR = 0x000000FF;					// Самые быстрые фронты для UART, у остальных мдленные

		//CAN2	только для отладочной платы....................................................................................
	MDR_PORTF->OE			|= (0<<2) | (1<<3);                     
	MDR_PORTF->FUNC   |= (3<<4) | (3<<6); 											//3 - переопред 2 - альтернат 1 - основ 0 - порт
	MDR_PORTF->ANALOG |= (1<<2) | (1<<3);                 
	MDR_PORTF->PWR		|= (2<<4) | (2<<6);													//2 - быстрый порт

}

//---------------------------------------------------------------------------------------------------------------------------------
// Инициализация АЦП и включение его прерываний
/* Выполняется именно одиночное преобразование, так как при последовательном опросе временами наблюдается переписывание результата
	(устанавливается флаг ADC_STATUS_FLG_REG_OVERWRITE), что приводит к проскакиванию одного из значений.
	Другой возможный вариант решения проблемы - снижение скорости АЦП изменение источника тактирования на более медленный.
	Кроме того, выбранный способ обеспечивает более полный контроль над процессом.
*/
void ADC_Init (void)
{
//	MDR_RST_CLK->ADC_MCO_CLOCK = (2 << RST_CLK_ADC_MCO_CLOCK_ADC_C2_SEL_Pos) |		// Биты выбора источника для ADC_C2: 10 – ADC_C1
//															 (8 << RST_CLK_ADC_MCO_CLOCK_ADC_C3_SEL_Pos) | 		// Биты выбора делителя для ADC_C3:  ADC_C3 = ADC _C2 / 2 / 28 = 142857
//																RST_CLK_ADC_MCO_CLOCK_ADC_CLK_EN;								// Включение тактирования на АЦП
//	
//	// Ининиализация АЦП1
//	MDR_ADC->ADC1_CFG = ADC1_CFG_REG_CLKS | 																			// Автоматический запуск после завершения предыдущего преобразования
//											(0 << ADC1_CFG_M_REF_Pos) |																// внутренне опорное напряжение (от AUсс и AGND);
//											(1 << ADC1_CFG_REG_CLKS_Pos);															// Выбор источника синхросигнала CLK работы ADC: 1 – ADC_CLK

	//											(0x4 << ADC1_CFG_REG_DIVCLK_Pos);													// 0x4 << 12 коэффициент деления частоты процессора: CPU_CLK = HCLK/16
	//MDR_ADC->ADC1_CFG = ADC1_CFG_REG_CLKS | ADC1_CFG_M_REF;												// Тактирование от генератора АЦП, внешний ИОН, всё без делителей, всё лишнее выключено
	MDR_ADC->ADC1_CFG = ADC1_CFG_REG_ADON |																				// Включение АЦП
											(3 << ADC1_CFG_REG_DIVCLK_Pos) |													// Выбор коэффициента деления частоты процессора 0011 – CPU_CLK = HCLK/8
											ADC1_CFG_TS_EN | 																					// Включения датчика температуры и источника опорного напряжения
											ADC1_CFG_REG_RNGC;																				// Разрешение автоматического контроля уровней
	MDR_ADC->ADC1_H_LEVEL = 0xFFF;
	//NVIC_EnableIRQ(ADC_IRQn);																											// Разрешить прерывание от АЦП в NVIC
}

// end of init.c
